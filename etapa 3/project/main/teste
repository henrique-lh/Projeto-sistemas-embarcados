#include "servo_tools.h"
#include "imu_tools.h"
#include "sensor_imu.h"
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "sdkconfig.h"
#include "esp_system.h"
#include "esp_random.h"
#include <math.h>
#include "driver/i2c.h"

#define degrees(x) (180 * x / M_PI)
#define GYRO_SCALE 131.0f 
#define DEG_TO_RAD (3.14159265358979323846 / 180.0f)
#define GRAVITY 9.81f
#define ACCEL_SCALE 16384


#define MPU6050_ADDR 0x68	// Endereço do sensor MPU6050
#define SDA_PIN GPIO_NUM_21 // Pino GPIO para SDA
#define SCL_PIN GPIO_NUM_22 // Pino GPIO para SCL

#define PI 3.14159265358979323846

double convert_scale(double angle) {
  double normalized = (2*angle + PI) / (2 * PI);

  return normalized * 180.0;
}


void app_main(void) {
  ServoConfig servo_config = {
    .gpio_num = 12, // Defina o GPIO que você está usando
    .mode = LEDC_HIGH_SPEED_MODE,
    .channel = LEDC_CHANNEL_0,
    .timer = LEDC_TIMER_0,
    .frequency = SERVO_PWM_FREQUENCY,
    .duty_resolution = LEDC_TIMER_13_BIT,
  };

  ServoConfig servo_config_2 = {
    .gpio_num = 13, // Defina o GPIO que você está usando
    .mode = LEDC_HIGH_SPEED_MODE,
    .channel = LEDC_CHANNEL_1,
    .timer = LEDC_TIMER_0,
    .frequency = SERVO_PWM_FREQUENCY,
    .duty_resolution = LEDC_TIMER_13_BIT,
  };

  if (servo_init(&servo_config) != ESP_OK) {
    printf("Falha ao inicializar o servo 1.\n");
    return;
  }

  if (servo_init(&servo_config_2) != ESP_OK) {
    printf("Falha ao inicializar o servo 2.\n");
    return;
  }

 
  esp_err_t result_imu = imu_init(MPU6050_ADDR, SDA_PIN, SCL_PIN);
  if (result_imu != ESP_OK)
  {
      printf("Falha na inicialização do IMU.");
      return;
  }
  IMUData data;
  Quaternion quaternion;
  EulerAngle eulerAngle;

  while (1)
  {
      // printf("*******************\n");
      // AccelerationData accel_data;
      // resultado = imu_get_acceleration_data(&accel_data);
      // if (resultado == ESP_OK)
      // {
      //     float acell_x = (accel_data.x/ACCEL_SCALE) * GRAVITY;
      //     float acell_y = (accel_data.y/ACCEL_SCALE) * GRAVITY;
      //     float acell_z = (accel_data.z/ACCEL_SCALE) * GRAVITY;
      //     printf("Aceleração (m/s): x = %f, y = %f, z = %f\n", acell_x, acell_y, acell_z);
      // } else
      // {
      //     printf("Falha ao obter dados de aceleração.\n");
      // }
      
      // GyroscopeData gyro_data;
      // resultado = imu_get_gyroscope_data(&gyro_data);
      // if (resultado == ESP_OK)
      // {
      //     float gyro_x_rad_s = (gyro_data.x / GYRO_SCALE);
      //     float gyro_y_rad_s = (gyro_data.y / GYRO_SCALE);
      //     float gyro_z_rad_s = (gyro_data.z / GYRO_SCALE);
      //     printf("Giroscópio (rad): x = %f, y = %f, z = %f\n", gyro_x_rad_s, gyro_y_rad_s, gyro_z_rad_s);
      // } else {
      //     printf("Falha ao obter dados do giroscópio.\n");
      // }

      // IMUData imu_data = {
      //     .acel_x = accel_data.x,
      //     .acel_y = accel_data.y,
      //     .acel_z = accel_data.z,
      //     .giro_x = gyro_data.x,
      //     .giro_y = gyro_data.y,
      //     .giro_z = gyro_data.z,
      // };

      // Quaternion quaternion;
      // resultado = imu_calculate_quaternion(&imu_data, &quaternion);
      // if (resultado == ESP_OK)
      // {
      //     printf("Quaternion: w = %f, x = %f, y = %f, z = %f\n", quaternion.w, quaternion.x, quaternion.y, quaternion.z);
      // }
      // else
      // {
      //     printf("Falha ao calcular o Quaternion.\n");
      // }

      // EulerAngle euler_angle;
      // resultado = imu_calculate_euler_angles(&quaternion, &euler_angle);
      // if (resultado == ESP_OK)
      // {
      //     printf("Ângulos de Euler: Roll = %f, Pitch = %f, Yaw = %f\n", euler_angle.roll, euler_angle.pitch, euler_angle.yaw);
      // }
      // else
      // {
      //     printf("Falha ao calcular os ângulos de Euler.\n");
      // }

      imu_read_data(&data);
      imu_calculate_quaternion(&data, &quaternion);
      imu_calculate_euler_angles(&quaternion, &eulerAngle);
      printf("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");      
      printf("Aceleração: X=%.2f, Y=%.2f, Z=%.2f g\n", data.accelData.accel_X, data.accelData.accel_Y, data.accelData.accel_Z);
      printf("Giroscopio: X=%.2d, Y=%.2d, Z=%.2d °/s\n", data.gyroData.rotation_X, data.gyroData.rotation_Y, data.gyroData.rotation_Z);
      printf("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
      printf("Quaternion: W=%.2f, X=%.2f, Y=%.2f, Z=%.2f\n", quaternion.w, quaternion.x, quaternion.y, quaternion.z);
      printf("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
      printf("Euler Angle: Roll=%.2f, Pitch=%.2f, Yaw=%.2f rad\n", eulerAngle.roll, eulerAngle.pitch, eulerAngle.yaw);
      printf("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");

      
      printf("ângulo do servo 1 %f.\n", convert_scale(-1*eulerAngle.pitch));
      if (servo_set_angle(&servo_config, convert_scale(-1*eulerAngle.pitch)) != ESP_OK) {
        printf("Falha ao definir o ângulo do servo 1 %f.\n", convert_scale(-1*eulerAngle.pitch));
      }  

      printf("ângulo do servo 2 %f.\n", convert_scale(eulerAngle.roll));
      if (servo_set_angle(&servo_config_2, convert_scale(eulerAngle.roll)) != ESP_OK) {
        printf("Falha ao definir o ângulo do servo 2 %f.\n", convert_scale(eulerAngle.roll));
      }  
      vTaskDelay(pdMS_TO_TICKS(1000));
  }
}
